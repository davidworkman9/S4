var sqlite3 = require('sqlite3').verbose(),
    crypto = require('crypto'),
    async = require('async'),
    storage = require('filestorage'),
    fs = require('fs'),
    _ = require('lodash');

function Bucket(name) {
    var self = this;
    self.name = name;
    self._db = new sqlite3.Database('dbs/bucket_' + name + '.db');
    self._storage = storage.create('./files/' + name);
    self._ready = false;
    self._readyFuncs = [];

    self._db.serialize(function () {
        var commands = [
            'CREATE TABLE IF NOT EXISTS files (key TEXT, fileId INTEGER)',
            'CREATE UNIQUE INDEX IF NOT EXISTS key_idx on files (key);',
            'CREATE UNIQUE INDEX IF NOT EXISTS fileId_idx on files (fileId);'
        ];
        async.each(commands, self._db.run.bind(self._db), self._setReady.bind(self));
    });
}

_.extend(Bucket.prototype, {
    _setReady: function () {
        var self = this;
        self._ready = true;
        self._readyFuncs.forEach(function (cb) { cb && cb(null, self); });
        self._readyFuncs = null;
    },
    _getFileIdByKey: function (key, cb) {
        this._db.get('SELECT fileId FROM files WHERE key=$key', { $key: key }, function (err, row) {
            row = row || {};
            cb(err, row.fileId);
        });
    },
    onReady: function (cb) {
        if (!cb)
            return;
        if (this._ready) {
            cb.apply(this);
        } else {
            this._readyFuncs.push(cb.bind(this));
        }
    },
    insertFile: function (key, fileStream, finishedCb) {
        var md5 = null,
            rowId = null,
            fileId = null,
            self = this;

        var generateHash = function (cb) {
            var md5sum = crypto.createHash('md5');
            fileStream.on('data', function (d) {
                md5sum.update(d);
            });

            fileStream.on('end', function () {
                md5 = md5sum.digest('hex');
                cb();
            });
        };

        var saveFile = function (cb) {
            self._storage.insert(key, fileStream, function (err, identifier, stat) {
                fileId = identifier;
                cb(err);
            });
        };

        var updateStorage = function (cb) {
            self._storage.update(fileId, function (err, header) {
                if (err)
                    return cb(err);
                var timeout = setTimeout(cb, 0);
                try {
                    header.custom = _.extend(header.custom || {}, {md5: md5});
                    return header;
                } catch (e) {
                    clearTimeout(timeout);
                    cb(e);
                }
            });
        };

        var updateFileId = function (cb) {
            self._db.serialize(function () {
                self._db.exec('BEGIN TRANSACTION;');
                self._db.run('DELETE FROM files WHERE key=$key', { $key: key });
                self._db.run('INSERT INTO files VALUES ($key, $fileId)', { $key: key, $fileId: fileId }, function (err) {
                    if (err) {
                        if (err && err.toString() === 'Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: files.fileId')
                            err = new Error('Fatal Error: File ID generated by file storage already in database');
                    }
                    rowId = this.lastID;
                    cb(err);
                });
                self._db.exec('COMMIT;');
            });
        };

        fileStream = typeof fileStream === 'string' ? fs.createReadStream(fileStream) : fileStream;
        async.parallel([generateHash, saveFile], function (err) {
            if (err) {
                return onError(function () {
                    finishedCb && finishedCb(err);
                });
            }

            async.parallel([updateStorage, updateFileId], function (err) {
                finishedCb && finishedCb(err, { rowId: rowId, key: key, fileId: fileId, md5: md5 });
            });
        });


        // rollback anything that possibly was committed.
        function onError (cb) {
            var funcs = [];

            if (fileId) {
                funcs.push(function (cb) {
                    self._storage.remove(fileId, cb);
                });
            }

            if (rowId) {
                funcs.push(function (cb) {
                    self._db.run('DELETE FROM files WHERE rowID=$rowId', { $rowId: rowId }, cb);
                });
            }

            async.parallel(funcs, cb);
        }
    },
    getFile: function (key, cb) {
        var self = this;
        self._getFileIdByKey(key, function (err, fileId) {
            if (err)
                return cb(err);
            self._storage.read(fileId, cb);
        });
    },
    pipeFile: function (key, stream) {
        var self = this;
        self._getFileIdByKey(key, function (err, fileId) {
            if (err)
                return cb(err);
            self._storage.pipe(fileId, stream);
        });
    },
    deleteFile: function (key, cb) {
        var self = this;
        self._getFileIdByKey(key, function (err, fileId) {
            if (err)
                return cb(err);
            self._storage.remove(fileId, cb);
        });
    },
    getMD5Hash: function (key, cb) {
        var self = this;
        self._getFileIdByKey(key, function (err, fileId) {
            if (err)
                return cb(err);
            self._storage.stat(fileId, function (err, stat) {
                cb(err, stat && stat.custom && stat.custom.md5);

            });
        });
    }
});

module.exports = {
    init: function (name, cb) {
        var bucket = new Bucket(name);
        bucket.onReady(cb);
        return bucket;
    }
};